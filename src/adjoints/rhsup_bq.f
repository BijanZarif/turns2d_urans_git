C        Generated by TAPENADE     (INRIA, Tropics team)
C  Tapenade 3.6 (r4343) - 10 Feb 2012 10:52
C
C  Differentiation of rhsup in reverse (adjoint) mode:
C   gradient     of useful results: q s
C   with respect to varying inputs: q s
C   RW status of diff variables: q:incr s:in-out
C***********************************************************************
      SUBROUTINE RHSUP_BQ(q, qb, s, sb, xx, xy, yx, yy, x, y, xv, yv, 
     +                    xold, yold, xole, yole, iblank, ugv, vgv, jd, 
     +                    kd, nei, im, bt)
      USE PARAMS_GLOBAL
      IMPLICIT NONE
      INCLUDE 'DIFFSIZES.inc'
C  Hint: ISIZE1OFpppbINrhsup should be the value of jd
C  Hint: ISIZE2OFpppbINrhsup should be the value of kd
C  Hint: ISIZE1OFfbINrhsup should be the value of mdim
C  Hint: ISIZE2OFfbINrhsup should be the value of nmv
C  Hint: ISIZE1OFqlbINrhsup should be the value of mdim
C  Hint: ISIZE2OFqlbINrhsup should be the value of nmv
C  Hint: ISIZE1OFqrbINrhsup should be the value of mdim
C  Hint: ISIZE2OFqrbINrhsup should be the value of nmv
C
C  muscl approach:
C  qt = 0                       1st-order  ; |irhsy| = 1
C  qt = 0.25
C    th = 0     upwind-biased   2nd-order  ; |irhsy| = 2
C    th = 1/3   upwind-biased   3rd-order  ; |irhsy| = 3
C
C
C***********************************************************************
C***********************************************************************
      INTEGER jd, kd, nei, im
      REAL q(jd, kd, nq), s(jd, kd, nv)
      REAL qb(jd, kd, nq), sb(jd, kd, nv)
      REAL xx(jd, kd), xy(jd, kd), yx(jd, kd), yy(jd, kd)
      REAL x(jd, kd), y(jd, kd), xv(jmax, kmax), yv(jmax, kmax)
      REAL ugv(jmax, kmax), vgv(jmax, kmax)
      REAL bt(jd, kd)
      REAL xold(jmax, kmax), yold(jmax, kmax)
      REAL xole(jmax, kmax), yole(jmax, kmax)
C local variables
      INTEGER iblank(jd, kd)
C
      REAL ppp(jd, kd)
      REAL tj(mdim), xa(mdim), ya(mdim)
      REAL f(mdim, nmv), ql(mdim, nmv), qr(mdim, nmv)
      REAL fmin(nmv), fmax(nmv)
      INTEGER iba(mdim)
      REAL a(mdim), b(mdim), c(mdim), fin(mdim), fout(mdim)
      REAL bbt(mdim)
C
C
      INTEGER irhs, ilima, k, j, jv, kv, jj
      REAL th, qt, eps, epsj, epsk, rhoi, dx2, dy2, temp
      REAL rhoib
      INTEGER ibmin, ibmax
      INTEGER arg1
      REAL pppb(jd, kd)
      REAL temp0b
      INTRINSIC ABS
      REAL fb(mdim, nmv)
      INTRINSIC REAL
      REAL qlb(mdim, nmv)
      INTRINSIC IABS
      REAL qrb(mdim, nmv)
      IF (irhsy .GE. 0) THEN
        irhs = irhsy
      ELSE
        irhs = -irhsy
      END IF
      IF (ilim .GE. 0.) THEN
        ilima = ilim
      ELSE
        ilima = -ilim
      END IF
C     limter = 1
C     if( irhs .eq. 2 .and. limter.eq.1 ) limter = 2
      th = REAL(irhs-2)/REAL(irhs)
      qt = 0.25
      IF (irhs .EQ. 1) qt = 0.0
      epsj = (10./REAL(jmax))**3
      epsk = (10./REAL(kmax))**3
C
      DO k=1,kd
        DO j=1,jd
          ppp(j, k) = gm1*(q(j, k, 4)-0.5*(q(j, k, 2)**2+q(j, k, 3)**2)/
     +      q(j, k, 1))
        ENDDO
      ENDDO
      fb = 0.0
      qlb = 0.0
      pppb = 0.0
      qrb = 0.0
      DO j=jbeg,jend
        jv = j - nhalo + 1
C
        DO k=1,kd
          rhoi = 1.0/q(j, k, 1)
          f(k, 1) = q(j, k, 1)*q(j, k, nq)
          f(k, 2) = q(j, k, 2)*rhoi
          f(k, 3) = q(j, k, 3)*rhoi
          f(k, 4) = ppp(j, k)*q(j, k, nq)
          IF (iblank(j, k) .GE. 0.) THEN
            iba(k) = iblank(j, k)
          ELSE
            iba(k) = -iblank(j, k)
          END IF
Cbt(j,k)
          bbt(k) = 1.
        ENDDO
C
C..at boundaries
        ibmin = 1
        ibmax = 1
C..limit
        IF (ilima .EQ. 0) THEN
          CALL IFLUX(f, ql, qr, 1, kd, arg1, th, qt, eps, fmin, fmax
     +                  , ibmin, ibmax, iba)
        END IF
        IF (ilima .EQ. 1) THEN
          arg1 = kd - 1
          CALL MUSCLD_NEW(f, ql, qr, 1, kd, arg1, th, qt, epsk, fmin
     +                       , fmax, ibmin, ibmax, iba)
C          call muscld(f,ql,qr,1,kd,kd-1,th,qt,eps,fmin,fmax,ibmin,ibmax)
        END IF
        IF (ilima .EQ. 2) THEN
          CALL QUAD(f, ql, qr, 1, kd, arg1, th, qt, eps, fmin, fmax, 
     +                 ibmin, ibmax)
        END IF
        IF (ilim .EQ. 4) THEN
          CALL WENO(f, ql, qr, 1, kd, arg1, th, qt, eps, fmin, fmax, 
     +                 ibmin, ibmax, iba)
        END IF
C
C..metric terms
C.do finite-volume like on finer mesh
C
        IF (nei .EQ. 0) THEN
          DO k=kbeg-1,kend
            kv = k - nhalo + 1
            xa(k) = -(yold(jv, kv)-yold(jv-1, kv))
            ya(k) = xold(jv, kv) - xold(jv-1, kv)
          ENDDO
        ELSE
          DO k=kbeg-1,kend
            kv = k - nhalo + 1
            xa(k) = -(yv(jv, kv)-yv(jv-1, kv))
            ya(k) = xv(jv, kv) - xv(jv-1, kv)
          ENDDO
        END IF
C
        IF (iunst .GT. 0) THEN
          DO k=kbeg-1,kend
            kv = k - nhalo + 1
            dx1 = xv(jv, kv) - xold(jv-1, kv)
            dy1 = yv(jv, kv) - yold(jv-1, kv)
            dx2 = xold(jv, kv) - xv(jv-1, kv)
            dy2 = yold(jv, kv) - yv(jv-1, kv)
            tj(k) = 0.5*(dx1*dy2-dx2*dy1)/dt
          ENDDO
          IF (ntac .EQ. 2 .AND. istep .GT. 1) THEN
            DO k=kbeg-1,kend
              kv = k - nhalo + 1
              dx1 = xold(jv, kv) - xole(jv-1, kv)
              dy1 = yold(jv, kv) - yole(jv-1, kv)
              dx2 = xole(jv, kv) - xold(jv-1, kv)
              dy2 = yole(jv, kv) - yold(jv-1, kv)
              temp = 0.5*(dx1*dy2-dx2*dy1)/dt
              tj(k) = 1.5*tj(k) - 0.5*temp
            ENDDO
          ELSE
          END IF
        ELSE IF (timespectral) THEN
          DO k=kbeg-1,kend
            kv = k - nhalo + 1
            tj(k) = -(0.5*(ugv(jv, kv)+ugv(jv-1, kv))*xa(k)) - 0.5*(vgv(
     +        jv, kv)+vgv(jv-1, kv))*ya(k)
          ENDDO
        ELSE
          DO k=kbeg-1,kend
            tj(k) = 0.
          ENDDO
        END IF
C
C..compute the generalized numerical flux in roe!'s upwinding
C
        IF (.NOT.iprecon) THEN
          arg1 = kbeg - 1
        ELSE
          arg1 = kbeg - 1
        END IF
        DO k=kbeg,kend
          fb(k, 4) = fb(k, 4) - sb(j, k, 4)
          fb(k-1, 4) = fb(k-1, 4) + sb(j, k, 4)
          fb(k, 3) = fb(k, 3) - sb(j, k, 3)
          fb(k-1, 3) = fb(k-1, 3) + sb(j, k, 3)
          fb(k, 2) = fb(k, 2) - sb(j, k, 2)
          fb(k-1, 2) = fb(k-1, 2) + sb(j, k, 2)
          fb(k, 1) = fb(k, 1) - sb(j, k, 1)
          fb(k-1, 1) = fb(k-1, 1) + sb(j, k, 1)
        ENDDO
        IF (iprecon) THEN
          CALL ROETRKLFLX_BQ(f, fb, ql, qlb, qr, qrb, xa, ya, tj, arg1, 
     +                       kend, bbt)
        ELSE
          CALL ROEFLX_BQ(f, fb, ql, qlb, qr, qrb, xa, ya, tj, arg1, kend
     +                  )
        END IF
        IF (ilima .eq. 4) CALL WENO_BQ(f, fb, ql, qlb, qr, qrb, 1, kd,
     +                                  arg1, th, qt, eps, fmin, fmax, 
     +                                  ibmin, ibmax, iba)
        IF (ilima .eq. 2) CALL QUAD_BQ(f, fb, ql, qlb, qr, qrb, 1, kd,
     +                                  arg1, th, qt, eps, fmin, fmax, 
     +                                  ibmin, ibmax)
        IF (ilima .eq. 1) THEN
          arg1 = kd - 1
          CALL MUSCLD_NEW_BQ(f, fb, ql, qlb, qr, qrb, 1, kd, arg1, th, 
     +                       qt, epsk, fmin, fmax, ibmin, ibmax, iba)
        END IF
        IF (ilima .eq. 0) CALL IFLUX_BQ(f, fb, ql, qlb, qr, qrb, 1, kd
     +                                   , arg1, th, qt, eps, fmin, fmax
     +                                   , ibmin, ibmax, iba)
        DO k=1,kd
          rhoi = 1.0/q(j, k, 1)
          pppb(j, k) = pppb(j, k) + q(j, k, nq)*fb(k, 4)
          qb(j, k, nq) = qb(j, k, nq) + ppp(j, k)*fb(k, 4)
          fb(k, 4) = 0.0
          qb(j, k, 3) = qb(j, k, 3) + rhoi*fb(k, 3)
          rhoib = q(j, k, 3)*fb(k, 3)
          fb(k, 3) = 0.0
          qb(j, k, 2) = qb(j, k, 2) + rhoi*fb(k, 2)
          rhoib = rhoib + q(j, k, 2)*fb(k, 2)
          fb(k, 2) = 0.0
          qb(j, k, 1) = qb(j, k, 1) + q(j, k, nq)*fb(k, 1)
          qb(j, k, nq) = qb(j, k, nq) + q(j, k, 1)*fb(k, 1)
          fb(k, 1) = 0.0
          qb(j, k, 1) = qb(j, k, 1) - rhoib/q(j, k, 1)**2
        ENDDO
      ENDDO
      DO k=kbeg,kend
        kv = k - nhalo + 1
C
        DO j=1,jd
          rhoi = 1.0/q(j, k, 1)
          f(j, 1) = q(j, k, 1)*q(j, k, nq)
          f(j, 2) = q(j, k, 2)*rhoi
          f(j, 3) = q(j, k, 3)*rhoi
          f(j, 4) = ppp(j, k)*q(j, k, nq)
          IF (iblank(j, k) .GE. 0.) THEN
            iba(j) = iblank(j, k)
          ELSE
            iba(j) = -iblank(j, k)
          END IF
Cbt(j,k)
          bbt(j) = 1.
        ENDDO
C..at boundaries
        ibmin = 1
        ibmax = 1
C..limit
        IF (ilima .EQ. 0) THEN
          CALL IFLUX(f, ql, qr, 1, jd, arg1, th, qt, eps, fmin, fmax
     +                  , ibmin, ibmax, iba)
        ELSE
        END IF
        IF (ilima .EQ. 1) THEN
          arg1 = jd - 1
          CALL MUSCLD_NEW(f, ql, qr, 1, jd, arg1, th, qt, epsj, fmin
     +                       , fmax, ibmin, ibmax, iba)
C         call muscld(f,ql,qr,1,jd,jd-1,th,qt,eps,fmin,fmax,ibmin,ibmax)
        END IF
        IF (ilima .EQ. 2) THEN
          CALL QUAD(f, ql, qr, 1, jd, arg1, th, qt, eps, fmin, fmax, 
     +                 ibmin, ibmax)
        END IF
        IF (ilim .EQ. 4) THEN
          CALL WENO(f, ql, qr, 1, jd, arg1, th, qt, eps, fmin, fmax, 
     +                 ibmin, ibmax, iba)
        END IF
C
C..metric terms
C.do finite-volume like on finer mesh
C
        IF (nei .EQ. 0) THEN
          DO j=jbeg-1,jend
            jv = j - nhalo + 1
            xa(j) = yold(jv, kv) - yold(jv, kv-1)
            ya(j) = -(xold(jv, kv)-xold(jv, kv-1))
          ENDDO
        ELSE
          DO j=jbeg-1,jend
            jv = j - nhalo + 1
            xa(j) = yv(jv, kv) - yv(jv, kv-1)
            ya(j) = -(xv(jv, kv)-xv(jv, kv-1))
          ENDDO
        END IF
C
        IF (iunst .GT. 0) THEN
          DO j=jbeg-1,jend
            jv = j - nhalo + 1
            dx1 = xv(jv, kv) - xold(jv, kv-1)
            dy1 = yv(jv, kv) - yold(jv, kv-1)
            dx2 = xold(jv, kv) - xv(jv, kv-1)
            dy2 = yold(jv, kv) - yv(jv, kv-1)
            tj(j) = -(0.5*(dx1*dy2-dx2*dy1)/dt)
          ENDDO
          IF (ntac .EQ. 2 .AND. istep .GT. 1) THEN
            DO j=jbeg-1,jend
              jv = j - nhalo + 1
              dx1 = xold(jv, kv) - xole(jv, kv-1)
              dy1 = yold(jv, kv) - yole(jv, kv-1)
              dx2 = xole(jv, kv) - xold(jv, kv-1)
              dy2 = yole(jv, kv) - yold(jv, kv-1)
              temp = -(0.5*(dx1*dy2-dx2*dy1)/dt)
              tj(j) = 1.5*tj(j) - 0.5*temp
            ENDDO
          ELSE
          END IF
        ELSE IF (timespectral) THEN
          DO j=jbeg-1,jend
            jv = j - nhalo + 1
            tj(j) = -(0.5*(ugv(jv, kv)+ugv(jv, kv-1))*xa(j)) - 0.5*(vgv(
     +        jv, kv)+vgv(jv, kv-1))*ya(j)
          ENDDO
        ELSE
          DO j=jbeg-1,jend
            tj(j) = 0.0
          ENDDO
        END IF
C
C..compute the generalized numerical flux in roe!'s upwinding
C
        IF (.NOT.iprecon) THEN
          arg1 = jbeg - 1
        ELSE
          arg1 = jbeg - 1
        END IF
        DO j=jbeg,jend
          fb(j, 4) = fb(j, 4) - sb(j, k, 4)
          fb(j-1, 4) = fb(j-1, 4) + sb(j, k, 4)
          fb(j, 3) = fb(j, 3) - sb(j, k, 3)
          fb(j-1, 3) = fb(j-1, 3) + sb(j, k, 3)
          fb(j, 2) = fb(j, 2) - sb(j, k, 2)
          fb(j-1, 2) = fb(j-1, 2) + sb(j, k, 2)
          fb(j, 1) = fb(j, 1) - sb(j, k, 1)
          fb(j-1, 1) = fb(j-1, 1) + sb(j, k, 1)
        ENDDO
        IF (iprecon) THEN
          CALL ROETRKLFLX_BQ(f, fb, ql, qlb, qr, qrb, xa, ya, tj, arg1, 
     +                       jend, bbt)
        ELSE
          CALL ROEFLX_BQ(f, fb, ql, qlb, qr, qrb, xa, ya, tj, arg1, jend
     +                  )
        END IF
        IF (ilima .eq. 4) CALL WENO_BQ(f, fb, ql, qlb, qr, qrb, 1, jd,
     +                                  arg1, th, qt, eps, fmin, fmax, 
     +                                  ibmin, ibmax, iba)
        IF (ilima .eq. 2) CALL QUAD_BQ(f, fb, ql, qlb, qr, qrb, 1, jd,
     +                                  arg1, th, qt, eps, fmin, fmax, 
     +                                  ibmin, ibmax)
        IF (ilima .eq. 1) THEN
          arg1 = jd - 1
          CALL MUSCLD_NEW_BQ(f, fb, ql, qlb, qr, qrb, 1, jd, arg1, th, 
     +                       qt, epsj, fmin, fmax, ibmin, ibmax, iba)
        END IF
        IF (ilima .eq. 0) CALL IFLUX_BQ(f, fb, ql, qlb, qr, qrb, 1, jd
     +                                   , arg1, th, qt, eps, fmin, fmax
     +                                   , ibmin, ibmax, iba)
        DO j=1,jd
          rhoi = 1.0/q(j, k, 1)
          pppb(j, k) = pppb(j, k) + q(j, k, nq)*fb(j, 4)
          qb(j, k, nq) = qb(j, k, nq) + ppp(j, k)*fb(j, 4)
          fb(j, 4) = 0.0
          qb(j, k, 3) = qb(j, k, 3) + rhoi*fb(j, 3)
          rhoib = q(j, k, 3)*fb(j, 3)
          fb(j, 3) = 0.0
          qb(j, k, 2) = qb(j, k, 2) + rhoi*fb(j, 2)
          rhoib = rhoib + q(j, k, 2)*fb(j, 2)
          fb(j, 2) = 0.0
          qb(j, k, 1) = qb(j, k, 1) + q(j, k, nq)*fb(j, 1)
          qb(j, k, nq) = qb(j, k, nq) + q(j, k, 1)*fb(j, 1)
          fb(j, 1) = 0.0
          qb(j, k, 1) = qb(j, k, 1) - rhoib/q(j, k, 1)**2
        ENDDO
      ENDDO
      DO k=1,kd
        DO j=1,jd
          temp0b = -(0.5*gm1*pppb(j, k)/q(j, k, 1))
          qb(j, k, 4) = qb(j, k, 4) + gm1*pppb(j, k)
          qb(j, k, 2) = qb(j, k, 2) + 2*q(j, k, 2)*temp0b
          qb(j, k, 3) = qb(j, k, 3) + 2*q(j, k, 3)*temp0b
          qb(j, k, 1) = qb(j, k, 1) - (q(j, k, 2)**2+q(j, k, 3)**2)*
     +      temp0b/q(j, k, 1)
          pppb(j, k) = 0.0
        ENDDO
      ENDDO
      END
